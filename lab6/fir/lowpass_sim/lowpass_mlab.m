%
%THIS IS A WIZARD GENERATED FILE. DO NOT EDIT THIS FILE!
%
%---------------------------------------------------------------------------------------------------------
%This is a filter with fixed coefficients.
%This Model Only Support Single Channel Input Data.
%Please input:
%data vector: 		stimulation(1:n)

%    This Model Only Support FIR_WIDTH to 51 Bits

%FILTER PARAMETER
%Input Data Type :	Signed Binary
%Input Data Width: 12
%Interpolation Factor: 1
%Decimation Factor: 1
%FIR Width (Full Calculation Width Before Output Width Adjust) :12
%-----------------------------------------------------------------------------------------------------------
%MegaWizard Scaled Coefficient Values

 function  output = lowpass_mlab(stimulation, output)
 coef_matrix_in= [-619,-87,-92,-99,-105,-111,-117,-124,-130,-137,-144,-150,-157,-164,-171,-177,-184,-191,-198,-204,-211,-217,-223,-229,-235,-241,-247,-252,-257,-262,-267,-271,-275,-279,-282,-285,-288,-290,-292,-294,-295,-296,-296,-296,-295,-294,-293,-291,-288,-285,-282,-278,-274,-269,-263,-258,-251,-244,-237,-230,-221,-213,-204,-194,-184,-175,-163,-152,-141,-129,-117,-105,-92,-80,-67,-54,-40,-27,-13,0,13,26,40,53,67,80,93,106,119,131,144,156,167,178,189,200,209,219,228,236,244,251,257,263,269,273,277,280,282,284,285,285,284,282,280,277,273,268,263,256,249,241,232,223,213,202,190,178,165,152,137,123,108,92,76,59,42,25,7,-10,-28,-46,-64,-83,-101,-120,-138,-156,-174,-192,-209,-226,-243,-259,-275,-290,-305,-318,-331,-344,-355,-365,-375,-384,-391,-398,-403,-407,-410,-412,-412,-411,-409,-406,-401,-394,-387,-377,-367,-355,-341,-326,-309,-291,-271,-250,-227,-203,-178,-151,-122,-93,-61,-29,4,39,75,112,151,190,231,273,315,358,402,447,493,539,585,632,680,728,776,824,872,920,968,1017,1064,1112,1159,1205,1252,1297,1342,1386,1429,1471,1512,1552,1591,1629,1665,1701,1734,1767,1797,1826,1854,1880,1904,1926,1947,1966,1982,1997,2010,2021,2030,2037,2042,2046,2046,2046,2042,2037,2030,2021,2010,1997,1982,1966,1947,1926,1904,1880,1854,1826,1797,1767,1734,1701,1665,1629,1591,1552,1512,1471,1429,1386,1342,1297,1252,1205,1159,1112,1064,1017,968,920,872,824,776,728,680,632,585,539,493,447,402,358,315,273,231,190,151,112,75,39,4,-29,-61,-93,-122,-151,-178,-203,-227,-250,-271,-291,-309,-326,-341,-355,-367,-377,-387,-394,-401,-406,-409,-411,-412,-412,-410,-407,-403,-398,-391,-384,-375,-365,-355,-344,-331,-318,-305,-290,-275,-259,-243,-226,-209,-192,-174,-156,-138,-120,-101,-83,-64,-46,-28,-10,7,25,42,59,76,92,108,123,137,152,165,178,190,202,213,223,232,241,249,256,263,268,273,277,280,282,284,285,285,284,282,280,277,273,269,263,257,251,244,236,228,219,209,200,189,178,167,156,144,131,119,106,93,80,67,53,40,26,13,0,-13,-27,-40,-54,-67,-80,-92,-105,-117,-129,-141,-152,-163,-175,-184,-194,-204,-213,-221,-230,-237,-244,-251,-258,-263,-269,-274,-278,-282,-285,-288,-291,-293,-294,-295,-296,-296,-296,-295,-294,-292,-290,-288,-285,-282,-279,-275,-271,-267,-262,-257,-252,-247,-241,-235,-229,-223,-217,-211,-204,-198,-191,-184,-177,-171,-164,-157,-150,-144,-137,-130,-124,-117,-111,-105,-99,-92,-87,-619];
 INTER_FACTOR  = 1;
 DECI_FACTOR  =  1;
 MSB_RM  = 0;
 MSB_TYPE  = 1;
 LSB_RM  = 21;
 LSB_TYPE  = 0;
 FIR_WIDTH  = 12 + MSB_RM + LSB_RM;
 OUT_WIDTH  = 12 ;  %12
 DATA_WIDTH = 12;
 BANKCOUNT = 1;
 data_type = 1;

  
 % check size of inputs. 
 [DX,DY] = size(stimulation);
 [CX,CY] = size(coef_matrix_in); 
 if (CY ~= DY * INTER_FACTOR) 
    fprintf('WARNING : coef_matrix size and input data size is not match\n'); 
 end 

 %fill coef_matrix to length of data with the latest coef set 
 if (CY < DY * INTER_FACTOR) 
   %for i= CX +1:DY * INTER_FACTOR 
   for i= 1:DY * INTER_FACTOR 
     if (BANKCOUNT > 1)
       coef_matrix(i,:) = coef_matrix_in(bank(i)+1,:); 
     else
       coef_matrix(i,:) = coef_matrix_in(1,:); 
     end
   end 
 end
	  
 % check if input is integer 
       	int_sti=round(stimulation); 
	    T = (int_sti ~= stimulation); 
	    if (max(T)~=0) 
	        fprintf('WARNING : Integer Input Expected: Rounding Fractional Input to Nearest Integer...\n'); 
	    end 
	     
	    %Input overflow check 
	    switch  data_type 
	    case 1 
	        %set max/min for signed 
	        maxdat = 2^(DATA_WIDTH-1)-1; 
	        mindat = -maxdat-1; 
	    case 2 
	        %set max/min for unsigned 
	        maxdat = 2^DATA_WIDTH-1; 
	        mindat = 0; 
	    end 

	    if(data_type == 2)
	    	if(abs(coef_matrix) == coef_matrix)
	    		FIR_WIDTH = FIR_WIDTH +1;
	    	end
	    end

	    %Saturating Input Value 
	    a=find(int_sti>maxdat); 
	    b=find(int_sti<mindat); 
	    if (~isempty(a)|~isempty(b)) 
	 	    fprintf('WARNING : Input Amplitude Exceeds MAXIMUM/MINIMUM allowable values - saturating input values...\n'); 
	            lena = length (a); 
	            lenb = length (b); 
	            for i =1:lena 
	        	    fprintf('%d > %d \n', int_sti(a(i)), maxdat); 
			        int_sti(a(i)) = maxdat; 
		        end 
		    for i =1:lenb 
			    fprintf('%d < %d \n', int_sti(b(i)), mindat); 
			    int_sti(b(i)) = mindat; 
		    end 
	    end 
         
	    % Add interpolation 
   	    inter_sti = zeros(1, INTER_FACTOR * length(int_sti)); 
	    inter_sti(1:INTER_FACTOR:INTER_FACTOR * length(int_sti)) = int_sti; 
 
         
        for i = 1 : DY *INTER_FACTOR 
    	    coef_current = coef_matrix(i,:); 
            output_temp(i) = simp_adaptive (inter_sti, coef_current, i); 
        end 
	% Truncate output 
	len1 = length(output_temp); 
	 
	    switch  LSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_lsb(output_temp,LSB_RM,FIR_WIDTH); 
	    case 1 
	        %round 
            out_dec = bi_round(output_temp,LSB_RM, FIR_WIDTH); 
	    end 
         
 	    switch  MSB_TYPE 
	    case 0 
	        %truncate 
            out_dec = bi_trunc_msb(out_dec,MSB_RM,FIR_WIDTH-LSB_RM); 
	    case 1 
	        %round 
            out_dec = bi_satu(out_dec,MSB_RM, FIR_WIDTH-LSB_RM); 
	    end 
 	    
    	% choose decimation output in phase=DECI_FACTOR-1  
     	if(DECI_FACTOR == 1) 
     		output = out_dec; 
     	else 
        output = out_dec(1:DECI_FACTOR:len1);

	 	end  
 	       
  	function[output, outindex] = simp_adaptive (int_sti, coef_current, data_index, output) 
	%Simulation is the whole input sequence 
	%coef_current is the current coefficient set 
	%data_index gives the last data to use 
	%outputs are the sum of input and coef multiplication 
	%outindex is the next data_index 
    
	sti_current = zeros(length(coef_current),1); 
	 
	data_length = length(int_sti); 
	 
	%Check data index 
	if (data_index > data_length) 
		fprintf('ERROR: DATA INDEX IS LARGER THAN DATA LENGTH!!!\n'); 
		return; 
	end 
	for i = 1: length(coef_current) 
	   if ((data_index -i+1)>0 & (data_index - i+1)<=data_length) 
	      sti_current(i,1) = int_sti(data_index - i+1); 
	   end 
	end 
	 
	outindex= data_index+1; 
	output = coef_current * sti_current; 
	% end of function simp_adaptive 
 
	function output = bi_round(data_in,LSB_RM,ORI_WIDTH, output) 
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width

	data = round (data_in / 2^LSB_RM);

	output = bi_satu(data,0,ORI_WIDTH - LSB_RM); 
	%end of function bi_trunc_lsb 
	 
	function output = bi_trunc_lsb(data_in,LSB_RM,ORI_WIDTH, output) 
	% LSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	output = bitshift(2^ORI_WIDTH*(data_in<0) + data_in, -LSB_RM) - 2^(ORI_WIDTH-LSB_RM) *(data_in<0); 
	% end of function bi_round 
	 
	function output = bi_trunc_msb(data_in,MSB_RM,ORI_WIDTH, output) 
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	data = 2^ORI_WIDTH * (data_in < 0)+ data_in; 
	erase_num = 2^(ORI_WIDTH - MSB_RM) - 1; 
	data = bitand(data, erase_num); 
	output = data - 2^(ORI_WIDTH - MSB_RM)*(bitget(data,ORI_WIDTH - MSB_RM)); 
	%end of bi_trunc_msb 
	 
	function output = bi_satu(data_in,MSB_RM,ORI_WIDTH, output) 
	% MSB_RM is the bit to lose in LSB 
	% ORI_WIDTH is the original data width 
	%2's complement system 
	maxdat = 2^(ORI_WIDTH - MSB_RM - 1)-1; 
	mindat = 2^(ORI_WIDTH - MSB_RM - 1)*(-1); 
	data_in(find(data_in > maxdat)) = maxdat; 
	data_in(find(data_in < mindat)) = mindat; 
	output = data_in; 
	%end of bi_satu  


